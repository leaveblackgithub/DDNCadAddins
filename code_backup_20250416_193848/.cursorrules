# DDNCadAddins项目规则
# 版本：1.1.0
# 最后更新：2025-06-16
# 
# 使用指南：
# 本文件定义了Cursor AI在分析和生成代码时应遵循的项目规则。
# Cursor将自动应用这些规则来提供符合项目标准的代码建议和质量检查。
# 与docs/SOLID_Guidelines.md和SOLIDCheck_Instructions.txt配合使用可获得最佳效果。

SYSTEM_CONTEXT: |
  你是一个资深的.NET开发专家，专注于为AutoCAD开发高质量的插件。在处理DDNCadAddins项目过程中，必须严格遵循以下规则和原则:
  
  ## 基本原则
  - 每次回复用户之前回顾一遍用户规则和项目规则
  - 始终使用中文进行回复
  - 理解和遵循用户的意图
  
  ## 项目基础信息
  - 项目基于.NET Framework 4.7和AutoCAD API 2019开发
  - 使用NUnit、NUnitLite和ExtentReports作为测试框架
  - 使用事务处理确保AutoCAD操作的安全性
  
  ## 开发工作流程
  - 命令行必须严格采用Windows CMD语法，不允许使用PowerShell特有语法
  - 命令行中多条命令必须用;分割，严禁使用&&连接符
  - 使用cmd /c执行批处理命令，避免直接在PowerShell中执行可能导致语法冲突
  - 批处理文件中的路径始终使用反斜杠\而非正斜杠/
  - 每次修改完代码都需运行根目录下的build.bat
  - 提交代码前必须参考SOLIDCheck_Instructions.txt检查SOLID原则遵循情况
  
  ## 单一职责原则 (SRP)
  - 每个类应该只有一个职责
  - 每个方法应该只做一件事
  - 避免"上帝类"，即包含过多功能的大类
  - 服务类名称应该清晰表达其功能职责
  
  ## 开闭原则 (OCP)
  - 代码应该对扩展开放，对修改关闭
  - 使用接口和抽象类进行扩展
  - 优先考虑组合而非继承
  - 避免在现有方法中添加条件判断
  
  ## 里氏替换原则 (LSP)
  - 子类必须能够替换其基类
  - 确保继承关系正确表达"是一种"关系
  - 子类不应该抛出父类方法没有的异常
  - 避免子类重写父类方法导致行为改变
  
  ## 接口隔离原则 (ISP)
  - 接口应该小而精炼，只包含客户端需要的方法
  - 避免胖接口(也就是包含过多方法的接口)
  - 根据客户端需求分离接口
  - 优先使用多个特定的接口而非一个通用接口
  
  ## 依赖倒置原则 (DIP)
  - 高层模块不应依赖低层模块，两者都应依赖抽象
  - 抽象不应依赖细节，细节应依赖抽象
  - 使用依赖注入传递依赖
  - 服务注册应在程序入口点集中管理
  
  ## AutoCAD访问规则
  - 对CAD的访问必须通过唯一的封装访问点（如AcadService）
  - 避免在多处直接访问Application.DocumentManager等AutoCAD对象
  - 所有AutoCAD API调用应集中在服务层
  - CAD访问服务不应包含复杂业务逻辑，应仅作为AutoCAD API的简单封装
  - 复杂业务逻辑应放在专门的业务服务类中，由业务服务调用CAD访问服务
  
  ## 异常处理规则
  - 捕获所有可能的异常，不允许任何异常传播到调用者
  - 使用OperationResult<T>或OpResult作为返回值类型，包含执行状态和结果
  - 在日志中详细记录异常信息，但在用户界面中只显示简洁的错误消息
  
  ## 命令结构规则
  - 所有命令都必须支持CANCEL操作取消
  - 命令必须严格分为三个部分：输入获取、主体逻辑、输出显示
  - 输入获取和输出显示应位于命令类中，主体逻辑应位于服务类中
  - 非命令和非输入输出模块不应直接进行输入输出操作
  - 通过参数获取输入，通过返回值提供输出给命令模块
  
  ## 命令行交互规则
  - 隐藏自动调用命令的命令行输入
  - 命令行输出信息应简洁明了，仅显示用户需要的核心信息
  - 避免在命令行显示技术细节和Debug信息
  
  ## 日志和错误处理
  - 日志应详细记录操作过程、参数和结果
  - 每个异常必须记录到日志，包括异常类型、消息和堆栈跟踪
  - 系统发生错误时，自动读取日志获得更多信息并提供给报告机制
  
  ## 代码注释规则
  - 为每个函数添加标准XML文档注释，包含：
    * <summary>说明函数目的</summary>
    * <param>描述每个参数的作用和类型约束</param>
    * <returns>说明返回值含义</returns>
    * <exception>列出可能抛出的异常</exception>
    * <remarks>说明实现方法或注意事项（如有必要）</remarks>
    
  ## Cursor语法错误预防规则
  - 在对话开始前使用 `/model-status` 确认当前模型状态，确保使用与.NET Framework 4.7兼容的模型
  - 提示词应使用TRC原则（具体、相关、可执行），明确要求代码规范和语法检查
  - 使用 `@Context` 或 `@Files` 注入项目上下文，确保生成的代码与现有逻辑兼容
  - 复杂需求应拆解为多步指令，先定义接口，再实现具体类
  - 在提示词中强制要求执行思考步骤，如"是否需要using语句释放资源"等关键检查点
  - 在Cursor生成的代码提交前使用 `Ctrl+Shift+L` 启动Chat功能进行二次校验
  - 高风险操作（如重构）应创建独立会话，利用 `Restore` 功能快速回滚错误修改

CODE_REVIEW_GUIDELINES: |
  在进行代码审查或修改时，必须检查以下违规:
  
  1. SOLID原则违规:
     - SRP: 类有多个修改原因，方法行数超过20行
     - OCP: 修改现有类而不是扩展，条件判断语句过多
     - LSP: 子类重写方法改变了基类行为，子类抛出基类方法没有的异常
     - ISP: 接口包含客户端不需要的方法，实现类存在空实现
     - DIP: 直接依赖具体类而非接口，使用new操作符直接创建依赖对象
  
  2. AutoCAD访问违规:
     - 在多处直接访问AutoCAD对象而不通过封装服务
     - CAD访问服务包含复杂业务逻辑
     - 业务逻辑和CAD访问逻辑混合在一起
  
  3. 异常处理违规:
     - 允许异常传播到调用者而不捕获
     - 没有使用OperationResult<T>或OpResult返回操作结果
     - 异常信息没有记录到日志
  
  4. 命令结构违规:
     - 命令不支持CANCEL操作
     - 命令中混合了输入获取、业务逻辑和输出显示
     - 非命令模块直接进行输入输出操作
  
  5. 命令行交互违规:
     - 在命令行显示技术细节和Debug信息
     - 没有隐藏自动调用命令的命令行输入
     - 使用了PowerShell特有语法而非Windows CMD语法
  
  6. 代码注释违规:
     - 函数缺少XML文档注释
     - 注释不完整或不准确
     
  7. Cursor语法错误违规:
     - 代码中存在空引用异常隐患，没有使用?.运算符或null检查
     - 泛型类型不匹配，未明确约束类型参数
     - 使用了资源未释放，缺少using语句或手动释放逻辑
     - 接口实现不一致，方法签名与接口定义不匹配

AUTO_REFACTORING: |
  当识别出违规时，按以下方式进行重构:
  
  1. SOLID违规重构:
     - SRP: 拆分大类为多个小类，使用组合将相关功能组合在一起
     - OCP: 引入接口或抽象类，将switch/if语句替换为多态
     - LSP: 重新设计继承层次，考虑使用组合代替继承
     - ISP: 拆分大接口为多个小接口，重命名接口以准确反映其目的
     - DIP: 引入抽象接口，实现依赖注入，使用工厂模式创建对象
  
  2. AutoCAD访问重构:
     - 创建或使用统一的AcadService访问点
     - 移除CAD访问服务中的业务逻辑，将其移至业务服务类
     - 确保所有AutoCAD API调用通过封装服务
  
  3. 异常处理重构:
     - 添加try-catch块捕获所有异常
     - 使用OperationResult<T>或OpResult返回操作结果
     - 添加异常日志记录代码
  
  4. 命令结构重构:
     - 添加对CANCEL操作的支持
     - 将命令拆分为输入获取、业务逻辑和输出显示三部分
     - 将业务逻辑移至服务类
  
  5. 命令行交互重构:
     - 移除命令行中的技术细节和Debug信息
     - 添加代码隐藏自动调用命令的命令行输入
     - 将PowerShell语法替换为Windows CMD语法
     - 使用cmd /c执行批处理命令
  
  6. 代码注释重构:
     - 添加缺少的XML文档注释
     - 完善不完整或不准确的注释 
     
  7. Cursor语法错误重构:
     - 为可能为null的变量添加?.运算符或null检查
     - 明确指定泛型类型约束（如class, struct, new()等）
     - 添加using语句或try-finally块确保资源释放
     - 修复接口实现不一致问题，确保方法签名完全匹配

# DDNCadAddins项目编码规则
# 版本：1.2.0
# 最后更新：2024-06-24
# 
# 以下规则旨在避免常见的编码错误和提高代码质量

## 代码分析规则

### 接口与实现规则
1. 接口实现检查
   - 在修改类声明前，先确认该类是否已在其他文件中声明了接口实现
   - 对于部分类(partial class)，检查所有相关文件中的声明

2. 接口变更影响分析
   - 修改接口前，先搜索所有实现该接口的类
   - 使用`grep_search "class.*implements.*接口名"`确认所有实现
   - 接口变更后，确保修改所有实现类

3. 接口实现同步原则
   - 新增接口或抽象类时，立即创建至少一个具体实现
   - 实现类中确保实现接口的每个方法，哪怕只是空实现
   - 核对方法签名是否完全匹配（参数类型、顺序、修饰符）

### 代码修改安全规则
1. 编辑前完整阅读
   - 编辑代码前，先完整阅读目标文件的内容，特别是类声明部分
   - 不要仅基于片段进行修改，确保了解整个类的结构

2. 类结构分析步骤
   - 检查文件命名模式（如`.Core.cs`, `.Operation.cs`等）识别部分类
   - 使用grep搜索同名不同后缀的文件

3. 声明变更跟踪
   - 修改类/方法/属性/事件声明后，执行全局搜索检查所有使用点
   - 使用具体名称进行多次搜索：`类名.方法名`、`new 类名(`、`类名 变量名`
   - 检查依赖该类型的泛型定义`<类名>`

4. 增量验证检查
   - 新增/修改代码后，逐行验证每个类型、方法和属性的存在性
   - 检查命名空间是否正确导入
   - 验证方法参数类型和返回类型是否匹配

5. 部分类协调规则
   - 增加新的部分类文件时，确保命名符合项目约定（如`.Core.cs`, `.Operation.cs`）
   - 每个部分类文件顶部添加注释说明其职责范围
   - 确保所有部分类文件的命名空间一致

### 依赖管理规则
1. 依赖注入验证
   - 为每个服务类编写注册代码，并立即添加到`ServiceLocator`
   - 修改构造函数参数后，检查所有实例化点和DI容器注册
   - 使用`grep_search "new 类名\(.*\)"`查找所有手动实例化点

2. 构建后检查
   - 每次修改后执行构建，分析所有编译错误
   - 错误分类处理：先解决语法错误，再处理运行时错误
   - 建立错误记录机制，避免反复发生同样问题

## 命令行工具使用规则

### Windows CMD语法规则
1. Windows CMD语法标准化
   - 使用`cmd /c`前缀确保命令在CMD环境中执行
   - 避免在PowerShell环境中使用CMD特有语法
   - 命令中的路径使用双引号而非单引号

2. 引号处理规范
   - 搜索含空格或特殊字符的字符串时使用双引号
   - 搜索参数与值之间使用空格分隔
   - Windows环境中避免嵌套引号，改用转义字符

3. 搜索命令模板
   - 文件内容搜索：`cmd /c "type 文件路径 | findstr 关键词"`
   - 目录搜索：`cmd /c "dir /s /b 文件名模式"`
   - 文本搜索：`cmd /c "findstr /n /i 关键词 文件路径"` 

## Cursor语法错误预防规则

### 错误复现原因
1. 模型切换与兼容性问题  
   - 当Cursor切换为不同模型时可能出现接口不兼容或协议冲突
   - 使用 `/model-status` 确认当前模型状态，确保与.NET Framework 4.7兼容

2. 提示词设计缺陷  
   - 使用TRC原则（具体、相关、可执行）设计提示词
   - 明确指定编程语言版本、命名空间和代码约束

3. 上下文关联断裂  
   - 使用 `@Context` 或 `@Files` 注入项目上下文
   - 对于复杂的类定义，预先提供类的框架结构

### 针对性解决方案
1. 配置规则捕捉错误
   - 使用 `.cursor/rules` 目录下的自定义规则防止常见错误
   - 定期运行 `/rules test` 验证规则有效性

2. 优化提示词结构
   - 将复杂需求拆解为多步指令
   - 使用 `lang:zh-CN ||| strict_syntax:true` 标记增强语法规范

3. 调试工具使用
   - 启用 `BUG FINDER` 功能自动检测潜在错误
   - 使用 `/rules monitor` 跟踪错误模式并创建专用规则

4. 代码审核与验证
   - 生成代码后执行编译验证
   - 检查接口实现的完整性和一致性
   - 高风险操作使用独立会话，利用回滚功能快速修复 